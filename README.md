
## Домашнее задание 10. Функциональные выражения на Clojure

### Задание + модификации:

Задание
1. Разработайте функции constant, variable, add, subtract, multiply, divide и negate для представления арифметических выражений.
    *Пример описания выражения 2x-3:
(def expr
  (subtract
    (multiply
      (constant 2)
      (variable "x"))
    (constant 3)))
    * Выражение должно быть функцией, возвращающей значение выражения при подстановке переменных, заданных отображением. Например, (expr {"x" 2}) должно быть равно 1.
2. Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,
(parseFunction "(- (* 2 x) 3)")
должно быть эквивалентно expr.
3. Сложный вариант. Функции add, subtract, multiply и divide должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для +, -, *, /.
4. При выполнении задания следует обратить внимание на:
    *Выделение общего кода для операций.


Модификации
 * Дополнительно реализовать поддержку операций:
    * `sumSinh` – сумма гиперболических синусов аргументов, `(sumSinh 10 -10)` равно 0;
    * `sumCosh` – сумма гиперболических косинусов аргументов, `(sumCosh 5 7 8)` примерно равно 2113;
    * `meanSinh` – среднее гиперболических синусов аргументов,
        `(meanSinh 10 -10)` равно 0;
    * `meanCosh` – среднее гиперболических косинусов аргументов,
        `(meanCosh 5 7 8)` примерно равно 704.3;


## Домашнее задание 9. Линейная алгебра на Clojure

### Задание + модификации:

Задание
1. Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
    *скаляры – числа
    *векторы – векторы чисел;
    *матрицы – векторы векторов чисел.
2. Функции над векторами:
    *v+/v-/v*/vd – покоординатное сложение/вычитание/умножение/деление;
    *scalar/vect – скалярное/векторное произведение;
    *v*s – умножение на скаляр.
3. Функции над матрицами:
    *m+/m-/m*/md – поэлементное сложение/вычитание/умножение/деление;
    *m*s – умножение на скаляр;
    *m*v – умножение на вектор;
    *m*m – матричное умножение;
    *transpose – транспонирование;
4. Сложный вариант.
    *Ко всем функциям должны быть указаны контракты. Например, нельзя складывать вектора разной длины.
    *Все функции, кроме transpose, должны поддерживать произвольное число аргументов. Например (v+ [1 2] [3 4] [5 6]) должно быть равно [9 12].
5. При выполнении задания следует обратить внимание на:
    *Применение функций высшего порядка.
    *Выделение общего кода для операций.

Модификации
 * *3637*
    * Доопределим операции на случай, когда среди аргументов встречаются
      и числа и вектора, либо вектора разной длины, следующим образом:
        * Сконвертируем все числа в вектора длины 1;
        * Дополним все аргументы нулями до длины максимального из них;
        * Рекурсивно примерним операцию к полученным векторам.
    * Добавьте операции доопределённого
      сложения (`b+`), вычитания (`b-`), умножения (`b*`) и деления (`bd`).


## Домашнее задание 8. Обработка ошибок на JavaScript

### Задание + модификации:

Задание
1. Добавьте в предыдущее домашнее задание функцию parsePrefix(string), разбирающую выражения, задаваемые записью вида «(- (* 2 x) 3)». Если разбираемое выражение некорректно, метод parsePrefix должен бросать ошибки с человеко-читаемыми сообщениями.
2. Добавьте в предыдущее домашнее задание метод prefix(), выдающий выражение в формате, ожидаемом функцией parsePrefix.
3. При выполнении задания следует обратить внимание на:
    *Применение инкапсуляции.
    *Выделение общего кода для операций.
    *Минимизацию необходимой памяти.
    *Обработку ошибок.

Модификации
 * *Postfix*. Дополнительно реализовать поддержку:
    * Выражений в постфиксной записи:
        * `(2 3 +)` равно 5
        * функция `parsePostfix`
        * метод `postfix`
 * *3637*. Сделать модификацию *Postfix* и дополнительно реализовать поддержку:
    * функций произвольного числа аргументов:
        * `SumCb` (`sumCb`) – сумма кубов аргументов, `(sumCb 5 8 2)` равно 645;
        * `Rmc` (`rmc`) – кубический корень из среднего суммы кубов аргументов, `(rmc 5 8 2)` примерно равно 6;


## Домашнее задание 7. Объектные выражения на JavaScript

### Задание + модификации:

Задание
1. Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide, Negate для представления выражений с тремя переменными: x, y и z.
2. Функция parse должна осуществлять разбор выражений, записанных в обратной польской записи. Например, результатом
parse("x x 2    ** x * 1 +").evaluate(5, 0, 0)
должно быть число 76, а результатом
parse("x x 2    ** x * 1 +").toString()
— строка «x x 2    ** x * 1 +».
3. Сложный вариант.
Метод diff("x") должен возвращать выражение, представляющее производную исходного выражения по переменной x. Например, expr.diff("x") должен возвращать выражение, эквивалентное new Const(2). Выражения new Subtract(new Const(2), new Const(0)) и
new Subtract(
    new Add(
        new Multiply(new Const(0), new Variable("x")),
        new Multiply(new Const(2), new Const(1))
    )
    new Const(0)
)
так же будут считаться правильным ответом.
4. (не реализовано) Бонусный вариант. Требуется написать метод simplify(), производящий вычисления константных выражений. Например,
parse("x x 2    ** 1 +").diff("x").simplify().toString()
должно возвращать «x x 2    *+» или аналогичное по сложности эквивалентное выражение.
5. При выполнении задания следует обратить внимание на:
    *Применение инкапсуляции.
    *Выделение общего кода для операций.
    *Минимизацию необходимой памяти.

Модификации
 * *3637*. Дополнительно реализовать поддержку:
    * функции от `N` аргументов для `N=1..5`:
        * `NormalN` (`normalN`) – плотность [многомерного нормального распределения](https://ru.wikipedia.org/wiki/Многомерное_нормальное_распределение#Плотность_невырожденного_нормального_распределения):\
          normalN(_x<sub>1</sub>_, …, _x<sub>n</sub>_) = e<sup>-Σ<sub>i=1..n</sub>x<sub>i</sub><sup>²</sup>/2</sup> / (2π)<sup>n/2</sup>,\
          `0.1 0.7 -1 normal3` примерно равно 0.03;


## Домашнее задание 6. Функциональные выражения на JavaScript

### Задание + модификации:

Задание
1. Разработайте функции cnst, variable, add, subtract, multiply, divide, negate для вычисления выражений с переменной x.
2. Функции должны позволять производить вычисления вида:
let expr = subtract(
    multiply(
        cnst(2),
        variable("x")
    ),
    cnst(3)
);

println(expr(5));
При вычислении выражения вместо переменной x подставляется значение, переданное в качестве аргумента функции expr. Таким образом, результатом вычисления приведенного примера должно быть число 7.
3. Тестовая программа должна вычислять выражение x2−2x+1, для x от 0 до 10.
4. Сложный вариант. Требуется дополнительно написать функцию parse, осуществляющую разбор выражений, записанных в обратной польской записи. Например, результатом
parse("x x 2    ** x * 1 +")(5)
должно быть число 76.
5. При выполнении задания следует обратить внимание на:
    *Применение функций высшего порядка.
    *Выделение общего кода для операций.

Модификации
 * *Mini* (для тестирования)
    * Не поддерживаются бинарные операции
    * Код находится в файле [functionalMiniExpression.js](javascript/functionalMiniExpression.js).
 * *3637*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`, `t`;
    * констант:
        * `tau` – 2π;
        * `phi` – (1 + √5) / 2;
    * операций сравнения, возвращающих 1 при истине и 0 при лжи:
        * `less3`          *три аргумента     упорядочены по возрастанию, `1 1 2 less3` равно 0;
        * `greater4`       *четыре аргумента  упорядочены по убыванию,    `5 4 3 2 greater4` равно 1;


## Домашнее задание 5. Очереди

### Задание + модификации:

Задание
1. Определите интерфейс очереди Queue и опишите его контракт.
2. Реализуйте класс LinkedQueue — очередь на связном списке.
3. Выделите общие части классов LinkedQueue и ArrayQueue в базовый класс AbstractQueue.
4. Все классы и интерфейсы должны быть параметризовани и типобезопастны.
Это домашнее задание связано с предыдущим.

Модификации
 * *3637*
    * Добавить в интерфейс очереди и реализовать методы
        * `filter(predicate)` – создать очередь, содержащую элементы, удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html)
        * `map(function)` – создать очередь, содержащую результаты применения
            [функции](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Function.html)
    * Исходная очередь должна остаться неизменной
    * Тип возвращаемой очереди должен соответствовать типу исходной очереди
    * Взаимный порядок элементов должен сохраняться
    * Дублирования кода быть не должно

## Домашнее задание 4. Очередь на массиве

### Задание + модификации:

Задание
1. Определите модель и найдите инвариант структуры данных «очередь».
    *Определите функции, которые необходимы для реализации очереди.
    *Найдите их пред- и постусловия, если очередь не может содержать null.
2. Реализуйте классы, представляющие циклическую очередь на основе массива.
    *Класс ArrayQueueModule должен реализовывать один экземпляр очереди с использованием переменных класса.
    *Класс ArrayQueueADT должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
    *Класс ArrayQueue должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
    *Должны быть реализованы следующие функции (процедуры) / методы:
    *- enqueue – добавить элемент в очередь;
    *- element – первый элемент в очереди;
    *- dequeue – удалить и вернуть первый элемент в очереди;
    *- size – текущий размер очереди;
    *- isEmpty – является ли очередь пустой;
    *- clear – удалить все элементы из очереди.
    *Модель, инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
    *Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
3. Напишите простые тесты к реализованным классам.
4. Классы ArrayQueueADT и ArrayQueue должны быть параметризованы и типобезопастны.

Модификации
 * *Deque*
    * Дополнительно реализовать методы
        * `push` – добавить элемент в начало очереди;
        * `peek` – вернуть последний элемент в очереди;
        * `remove` – вернуть и удалить последний элемент из очереди.
 * *3637*
    * Реализовать модификацию *Deque*
    * Реализовать методы
        * `get` – получить элемент по индексу, отсчитываемому с хвоста;
        * `set` – заменить элемент по индексу, отсчитываемому с хвоста.

## Домашнее задание 3. Бинарный поиск

### Задание + модификации:

Задание
1. Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
2. На вход подается целое число x и массив целых чисел a, отсортированный по невозрастанию. Требуется найти минимальное значение индекса i, при котором a[i] <= x.
3. Для main, функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
4. Интерфейс программы.
    *Имя основного класса — search.BinarySearch.
    *Первый аргумент командной строки — число x.
    *Последующие аргументы командной строки — элементы массива a.
5. Пример запуска: java search.BinarySearch 3 5 4 3 2 1. Ожидаемый результат: 2.

Модификации
 * *Choice* (36-39)
    * Если число чисел во входе чётное, то должна быть использована
      рекурсивная версия, иначе — итеративная.
 * *3637* (36, 37)
    * На вход подается число `x` и массив `a` полученный приписыванием
      в конец массива отсортированного (строго) по убыванию,
      массива отсортированного (строго) по возрастанию.
    * Требуется вывести индекс первого вхождения `x` в `a` или `-1`, если `x` не входит в `a`.
    * Класс должен иметь имя `BinarySearch3637`

## Домашнее задание 2. Вычисление в различных типах

### Задание не реализовано

## Домашнее задание 1. Обработка ошибок

### Задание не реализовано